[gd_scene load_steps=47 format=3 uid="uid://dt7c7s4m52uwy"]

[ext_resource type="Material" uid="uid://dfokgd1khhckl" path="res://Fnt, Img, Snd, Env, Tex/Textures/GrayGrid.tres" id="1_uisu2"]
[ext_resource type="Material" uid="uid://b4p7kyojic6jg" path="res://Assets/Particals/Waterfall/Waterfall.tres" id="2_a0r6c"]
[ext_resource type="FontFile" uid="uid://bt0htiehpoxc6" path="res://Fnt, Img, Snd, Env, Tex/Fonts/Rubik-Bold.ttf" id="3_w3bp8"]
[ext_resource type="Script" path="res://addons/proton_scatter/src/scatter.gd" id="3_x3dau"]
[ext_resource type="Script" path="res://addons/proton_scatter/src/stack/modifier_stack.gd" id="4_aa0xd"]
[ext_resource type="PackedScene" uid="uid://c7ga4svhijdy5" path="res://Assets/blend files/Bridge.blend" id="4_hjyux"]
[ext_resource type="PackedScene" uid="uid://bu1embbija8wm" path="res://Assets/blend files/Log.blend" id="5_wfq7t"]
[ext_resource type="Script" path="res://addons/proton_scatter/src/modifiers/create_inside_random.gd" id="5_y2str"]
[ext_resource type="Script" path="res://addons/proton_scatter/src/modifiers/randomize_transforms.gd" id="6_goa4k"]
[ext_resource type="Script" path="res://addons/proton_scatter/src/modifiers/relax.gd" id="7_ejpuv"]
[ext_resource type="Script" path="res://addons/proton_scatter/src/modifiers/project_on_geometry.gd" id="8_01k33"]
[ext_resource type="Script" path="res://addons/proton_scatter/src/scatter_item.gd" id="9_uqfs6"]
[ext_resource type="Script" path="res://addons/proton_scatter/src/scatter_shape.gd" id="10_sagxs"]
[ext_resource type="Script" path="res://addons/proton_scatter/src/shapes/box_shape.gd" id="11_3kkjq"]

[sub_resource type="GDScript" id="GDScript_s3x0h"]
script/source = "@tool
extends Node3D


signal shape_changed
signal thread_completed
signal build_completed


# Includes
#const ProtonScatter := preload(\"./scatter.gd\")
#const ProtonScatterDomain := preload(\"./common/domain.gd\")
#const ProtonScatterItem := preload(\"./scatter_item.gd\")
#const ProtonScatterModifierStack := preload(\"./stack/modifier_stack.gd\")
#const ProtonScatterPhysicsHelper := preload(\"./common/physics_helper.gd\")
#const ProtonScatterShape := preload(\"./scatter_shape.gd\")
#const ProtonScatterTransformList := preload(\"./common/transform_list.gd\")
#const ProtonScatterUtil := preload('./common/scatter_util.gd')


@export_category(\"ProtonScatter\")

@export_group(\"General\")
@export var global_seed := 0:
	set(val):
		global_seed = val
		rebuild()
@export var show_output_in_tree := false:
	set(val):
		show_output_in_tree = val
		if output_root:
			ProtonScatterUtil.enforce_output_root_owner(self)

@export_group(\"Performance\")
@export var use_instancing := true:
	set(val):
		use_instancing = val
		full_rebuild(true)

@export var force_rebuild_on_load := true
@export var enable_updates_in_game := false

@export_group(\"Dependency\")
@export var scatter_parent: NodePath:
	set(val):
		if not is_inside_tree():
			scatter_parent = val
			return

		scatter_parent = NodePath()
		if is_instance_valid(_dependency_parent):
			_dependency_parent.build_completed.disconnect(rebuild)
			_dependency_parent = null

		var node = get_node_or_null(val)
		if not node:
			return

		var type = node.get_script()
		var scatter_type = get_script()
		if type != scatter_type:
			push_warning(\"ProtonScatter warning: Please select a ProtonScatter node as a parent dependency.\")
			return

		# TODO: Check for cyclic dependency

		scatter_parent = val
		_dependency_parent = node
		_dependency_parent.build_completed.connect(rebuild, CONNECT_DEFERRED)


@export_group(\"Debug\", \"dbg_\")
@export var dbg_disable_thread := false

var undo_redo # EditorUndoRedoManager - Can't type this, class not available outside the editor
var modifier_stack: ProtonScatterModifierStack:
	set(val):
		if modifier_stack:
			if modifier_stack.value_changed.is_connected(rebuild):
				modifier_stack.value_changed.disconnect(rebuild)
			if modifier_stack.stack_changed.is_connected(rebuild):
				modifier_stack.stack_changed.disconnect(rebuild)
			if modifier_stack.transforms_ready.is_connected(_on_transforms_ready):
				modifier_stack.transforms_ready.disconnect(_on_transforms_ready)

		modifier_stack = val.get_copy() # Enfore uniqueness
		modifier_stack.value_changed.connect(rebuild, CONNECT_DEFERRED)
		modifier_stack.stack_changed.connect(rebuild, CONNECT_DEFERRED)
		modifier_stack.transforms_ready.connect(_on_transforms_ready, CONNECT_DEFERRED)

var domain: ProtonScatterDomain:
	set(val):
		domain = ProtonScatterDomain.new() # Enforce uniqueness

var items: Array = []
var total_item_proportion: int
var output_root: Marker3D

var editor_plugin # Holds a reference to the EditorPlugin. Used by other parts.

var _thread: Thread
var _rebuild_queued := false
var _dependency_parent
var _physics_helper: ProtonScatterPhysicsHelper
var _thread_just_started := false


func _exit_tree():
	if is_thread_running():
		_thread.wait_to_finish()
		_thread = null


func _ready() -> void:
	if Engine.is_editor_hint() or enable_updates_in_game:
		set_notify_transform(true)
		child_exiting_tree.connect(_on_child_exiting_tree)

	if not force_rebuild_on_load:
		return

	_perform_sanity_check()
	_discover_items()
	domain.discover_shapes(self)

	if not is_instance_valid(_dependency_parent):
		full_rebuild.call_deferred()


func _get_property_list() -> Array:
	var list := []
	list.push_back({
		name = \"modifier_stack\",
		type = TYPE_OBJECT,
		hint_string = \"ScatterModifierStack\",
	})
	return list


func _get_configuration_warnings() -> PackedStringArray:
	var warnings := PackedStringArray()
	if items.is_empty():
		warnings.push_back(\"At least one ScatterItem node is required.\")
	if domain.is_empty():
		warnings.push_back(\"At least one ScatterShape node is required.\")
	return warnings


func _notification(what):
	match what:
		NOTIFICATION_TRANSFORM_CHANGED:
			domain.compute_bounds()
			rebuild()


func _set(property, _value):
	if not Engine.is_editor_hint():
		return false

	# Workaround to detect when the node was duplicated from the editor.
	if property == \"transform\":
		_on_node_duplicated.call_deferred()

	return false


func is_thread_running() -> bool:
	return _thread != null and _thread.is_started()


# Used by some modifiers to retrieve a physics helper node
func get_physics_helper() -> ProtonScatterPhysicsHelper:
	if not is_instance_valid(_physics_helper):
		_physics_helper = ProtonScatterPhysicsHelper.new()
		add_child(_physics_helper)

	return _physics_helper


# Deletes what the Scatter node generated.
func clear_output() -> void:
	if not output_root:
		output_root = get_node_or_null(\"ScatterOutput\")

	if output_root:
		remove_child(output_root)
		output_root.queue_free()
		output_root = null

	ProtonScatterUtil.ensure_output_root_exists(self)


func full_rebuild(delayed := false):
	if not is_inside_tree():
		return

	update_gizmos()

	if delayed:
		await get_tree().process_frame

	if is_thread_running():
		_thread.wait_to_finish()
		_thread = null

	clear_output()
	_rebuild(true)


# A wrapper around the _rebuild function. Ensure it's not called more than once
# per frame. (Happens when the Scatter node is moved, which triggers the
# TRANSFORM_CHANGED notification in every children, which in turn notify the
# parent Scatter node back about the changes.
func rebuild(force_discover := false) -> void:
	update_gizmos()

	if not is_inside_tree():
		return

	if is_thread_running():
		_rebuild_queued = true
		return

	force_discover = true # TMP while we fix the other issues
	_rebuild(force_discover)


# Re compute the desired output.
# This is the main function, scattering the objects in the scene.
# Scattered objects are stored under a Marker3D node called \"ScatterOutput\"
# DON'T call this function directly outside of the 'rebuild()' function above.
func _rebuild(force_discover) -> void:
	if force_discover:
		_discover_items()
		domain.discover_shapes(self)

	if items.is_empty() or domain.is_empty():
		clear_output()
		push_warning(\"ProtonScatter warning: No items or shapes, abort\")
		return

	if not use_instancing:
		clear_output() # TMP, prevents raycasts in modifier to self intersect with previous output

	if dbg_disable_thread:
		modifier_stack.start_update(self, domain)
		return

	if _thread:
		await _thread.wait_to_finish()

	_thread = Thread.new()
	var update_function := modifier_stack.start_update.bind(self, domain.get_copy())
	_thread.start(update_function, Thread.PRIORITY_NORMAL)


func _discover_items() -> void:
	items.clear()
	total_item_proportion = 0

	for c in get_children():
		if c is ProtonScatterItem:
			items.push_back(c)
			total_item_proportion += c.proportion

	if is_inside_tree():
		get_tree().node_configuration_warning_changed.emit(self)


# Creates one MultimeshInstance3D for each ScatterItem node.
func _update_multimeshes(transforms: ProtonScatterTransformList) -> void:
	var offset := 0
	var transforms_count: int = transforms.size()
	var inverse_transform := global_transform.affine_inverse()

	for item in items:
		var item_root = ProtonScatterUtil.get_or_create_item_root(item)
		var count = int(round(float(item.proportion) / total_item_proportion * transforms_count))
		var mmi = ProtonScatterUtil.get_or_create_multimesh(item, count)
		if not mmi:
			return

		var t: Transform3D
		for i in count:
			# Extra check because of how 'count' is calculated
			if (offset + i) >= transforms_count:
				mmi.multimesh.instance_count = i - 1
				return

			t = item.process_transform(transforms.list[offset + i])
			mmi.multimesh.set_instance_transform(i, inverse_transform * t)

		offset += count


func _update_duplicates(transforms: ProtonScatterTransformList) -> void:
	var offset := 0
	var transforms_count: int = transforms.size()
	var inverse_transform := global_transform.affine_inverse()

	for item in items:
		var count = int(round(float(item.proportion) / total_item_proportion * transforms_count))
		var root = ProtonScatterUtil.get_or_create_item_root(item)
		var child_count = root.get_child_count()

		for i in count:
			if (offset + i) >= transforms_count:
				return

			var instance
			if i < child_count: # Grab an instance from the pool if there's one available
				instance = root.get_child(i)
			else:
				instance = _create_instance(item, root)

			if not instance:
				break

			var t: Transform3D = item.process_transform(transforms.list[offset + i])
			instance.transform = inverse_transform * t

		# Delete the unused instances left in the pool if any
		if count < child_count:
			for i in (child_count - count):
				root.get_child(-1).queue_free()

		offset += count


func _create_instance(item: ProtonScatterItem, root: Node3D):
	if not item or not item.get_item():
		return null

	var instance = item.get_item().duplicate()
	instance.visible = true
	root.add_child.bind(instance, true).call_deferred()

	if show_output_in_tree:
		var defer_ownership := func(i, o):
			ProtonScatterUtil.set_owner_recursive(i, o)
		defer_ownership.bind(instance, get_tree().get_edited_scene_root()).call_deferred()

	return instance


# Enforce the Scatter node has its required variables set.
func _perform_sanity_check() -> void:
	if not modifier_stack:
		modifier_stack = ProtonScatterModifierStack.new()
		modifier_stack.just_created = true

	if not domain:
		domain = ProtonScatterDomain.new()

	scatter_parent = scatter_parent # TODO: Why ?


func _on_node_duplicated() -> void:
	clear_output() # Otherwise we get linked multimeshes or other unwanted side effects
	_perform_sanity_check()


func _on_child_exiting_tree(node: Node) -> void:
	if node is ProtonScatterShape or node is ProtonScatterItem:
		rebuild.bind(true).call_deferred()


# Called when the modifier stack is done generating the full transform list
func _on_transforms_ready(transforms: ProtonScatterTransformList) -> void:
	if is_thread_running():
		_thread.wait_to_finish()
		_thread = null

	if _rebuild_queued:
		_rebuild_queued = false
		rebuild.call_deferred()
		return

	if not transforms or transforms.is_empty():
		clear_output()
		update_gizmos()
		return

	if use_instancing:
		_update_multimeshes(transforms)
	else:
		_update_duplicates(transforms)

	update_gizmos()
	await get_tree().process_frame
	build_completed.emit()
"

[sub_resource type="GDScript" id="GDScript_jiclh"]
script/source = "@tool
extends Resource


signal stack_changed
signal value_changed
signal transforms_ready


const ProtonScatter := preload(\"../scatter.gd\")
const TransformList = preload(\"../common/transform_list.gd\")


@export var stack: Array[Resource] = []

var just_created := false


func start_update(scatter_node: ProtonScatter, domain) -> void:
	var transforms = TransformList.new()

	for modifier in stack:
		await modifier.process_transforms(transforms, domain, scatter_node.global_seed)

	transforms_ready.emit(transforms)


func add(modifier) -> void:
	stack.push_back(modifier)
	stack_changed.emit()


func move(old_index: int, new_index: int) -> void:
	var modifier = stack.pop_at(old_index)
	stack.insert(new_index, modifier)
	stack_changed.emit()


func remove(modifier) -> void:
	if stack.has(modifier):
		stack.erase(modifier)
		stack_changed.emit()


func remove_at(index: int) -> void:
	if stack.size() > index:
		stack.remove_at(index)
		stack_changed.emit()


func duplicate_modifier(modifier) -> void:
	var index: int = stack.find(modifier)
	if index != -1:
		var duplicate = modifier.get_copy()
		add(duplicate)
		move(stack.size() - 1, index + 1)


func get_copy():
	var copy = get_script().new()
	for modifier in stack:
		copy.stack.push_back(modifier.duplicate())
	return copy


func get_index(modifier) -> int:
	return stack.find(modifier)


func is_using_edge_data() -> bool:
	for modifier in stack:
		if modifier.use_edge_data:
			return true

	return false


# Returns true if at least one modifier does not require shapes in order to work.
# (This is the case for the \"Add single item\" modifier for example)
func does_not_require_shapes() -> bool:
	for modifier in stack:
		if modifier.warning_ignore_no_shape:
			return true

	return false
"

[sub_resource type="GDScript" id="GDScript_cmkkw"]
script/source = "@tool
extends \"base_modifier.gd\"


@export var amount := 10

var _rng: RandomNumberGenerator


func _init() -> void:
	display_name = \"Create Inside (Random)\"
	category = \"Create\"
	warning_ignore_no_transforms = true
	warning_ignore_no_shape = false
	can_override_seed = true
	global_reference_frame_available = true
	local_reference_frame_available = true
	use_local_space_by_default()

	documentation.add_paragraph(
		\"Randomly place new transforms inside the area defined by
		the ScatterShape nodes.\")

	var p := documentation.add_parameter(\"Amount\")
	p.set_type(\"int\")
	p.set_description(\"How many transforms will be created.\")
	p.set_cost(2)

	documentation.add_warning(
		\"In some cases, the amount of transforms created by this modifier
		might be lower than the requested amount (but never higher). This may
		happen if the provided ScatterShape has a huge bounding box but a tiny
		valid space, like a narrow path.\")


# TODO:
# + Multithreading
# + Spatial partionning to discard areas outside the domain earlier
func _process_transforms(transforms, domain, seed) -> void:
	_rng = RandomNumberGenerator.new()
	_rng.set_seed(seed)

	var gt: Transform3D = domain.get_global_transform()
	var gt_inverse = gt.affine_inverse()
	var center: Vector3 = domain.bounds.center
	var half_size: Vector3 = domain.bounds.size / 2.0
	var height: float = domain.bounds.center.y

	# Generate a random point in the bounding box. Store if it's inside the
	# domain, or discard if invalid. Repeat until enough valid points are found.
	var t: Transform3D
	var pos: Vector3
	var new_transforms: Array[Transform3D] = []
	var max_retries = amount * 10
	var tries := 0

	while new_transforms.size() != amount:
		t = Transform3D()
		pos = _random_vec3() * half_size + center

		if restrict_height:
			pos.y = height

		if is_using_local_space():
			t.basis = gt.basis

		if domain.is_point_inside(pos):
			t.origin = pos
			new_transforms.push_back(t)
			continue

		# Prevents an infinite loop
		tries += 1
		if tries > max_retries:
			break

	transforms.append(new_transforms)


func _random_vec3() -> Vector3:
	var vec3 = Vector3.ZERO
	vec3.x = _rng.randf_range(-1.0, 1.0)
	vec3.y = _rng.randf_range(-1.0, 1.0)
	vec3.z = _rng.randf_range(-1.0, 1.0)
	return vec3
"

[sub_resource type="Resource" id="Resource_nvjs0"]
script = SubResource("GDScript_cmkkw")
amount = 75
enabled = true
override_global_seed = false
custom_seed = 0
restrict_height = true
reference_frame = 1

[sub_resource type="GDScript" id="GDScript_dv7ri"]
script/source = "@tool
extends \"base_modifier.gd\"


@export var position := Vector3.ONE
@export var rotation := Vector3(360.0, 360.0, 360.0)
@export var scale := Vector3.ONE

var _rng: RandomNumberGenerator


func _init() -> void:
	display_name = \"Randomize Transforms\"
	category = \"Edit\"
	can_override_seed = true
	can_restrict_height = false
	global_reference_frame_available = true
	local_reference_frame_available = true
	individual_instances_reference_frame_available = true
	use_individual_instances_space_by_default()


func _process_transforms(transforms, domain, seed) -> void:
	_rng = RandomNumberGenerator.new()
	_rng.set_seed(seed)

	var t: Transform3D
	var local_t: Transform3D
	var basis: Basis
	var random_scale: Vector3
	var random_position: Vector3
	var st: Transform3D = domain.get_global_transform()

	# Global rotation axis
	var axis_x := Vector3.RIGHT
	var axis_y := Vector3.UP
	var axis_z := Vector3.DOWN

	if is_using_local_space():
		axis_x = st.basis.x
		axis_y = st.basis.y
		axis_z = st.basis.z

	for i in transforms.size():
		t = transforms.list[i]
		basis = t.basis

		random_scale = Vector3.ONE + (_rng.randf() * scale)
		random_position = _random_vec3() * position

		if is_using_individual_instances_space():
			axis_x = basis.x
			axis_y = basis.y
			axis_z = basis.z
			basis.x *= random_scale.x
			basis.y *= random_scale.y
			basis.z *= random_scale.z
			random_position = t.basis * random_position

		elif is_using_local_space():
			local_t = t * st
			local_t.basis = local_t.basis.scaled(random_scale)
			basis = (st * local_t).basis

		else:
			basis = basis.scaled(random_scale)

		basis = basis.rotated(axis_x, deg_to_rad(_random_float() * rotation.x))
		basis = basis.rotated(axis_y, deg_to_rad(_random_float() * rotation.y))
		basis = basis.rotated(axis_z, deg_to_rad(_random_float() * rotation.z))

		t.origin += random_position
		t.basis = basis

		transforms.list[i] = t


func _random_vec3() -> Vector3:
	var vec3 = Vector3.ZERO
	vec3.x = _rng.randf_range(-1.0, 1.0)
	vec3.y = _rng.randf_range(-1.0, 1.0)
	vec3.z = _rng.randf_range(-1.0, 1.0)
	return vec3


func _random_float() -> float:
	return _rng.randf_range(-1.0, 1.0)


func _clamp_vector(vec3, vmin, vmax) -> Vector3:
	vec3.x = clamp(vec3.x, vmin.x, vmax.x)
	vec3.y = clamp(vec3.y, vmin.y, vmax.y)
	vec3.z = clamp(vec3.z, vmin.z, vmax.z)
	return vec3
"

[sub_resource type="Resource" id="Resource_v6ok5"]
script = SubResource("GDScript_dv7ri")
position = Vector3(0.15, 0.15, 0.15)
rotation = Vector3(20, 360, 20)
scale = Vector3(0.1, 0.1, 0.1)
enabled = true
override_global_seed = false
custom_seed = 0
restrict_height = false
reference_frame = 2

[sub_resource type="GDScript" id="GDScript_ntq0g"]
script/source = "@tool
extends \"base_modifier.gd\"


@export var iterations : int = 3
@export var offset_step : float = 0.01
@export var consecutive_step_multiplier : float = 0.5


func _init() -> void:
	display_name = \"Relax Position\"
	category = \"Edit\"
	global_reference_frame_available = false
	local_reference_frame_available = false
	individual_instances_reference_frame_available = false
	can_restrict_height = true
	restrict_height = true


func _process_transforms(transforms, domain, _seed) -> void:
	# TODO this can benefit greatly from multithreading
	if transforms.size() < 2:
		return

	var offset = offset_step

	for iteration in iterations:
		for i in transforms.size():
			var min_vector = Vector3.ONE * 99999
			# Find the closest point
			for j in transforms.size():
				if i == j:
					continue
				var d = transforms.list[i].origin - transforms.list[j].origin
				if d.length() < min_vector.length():
					min_vector = d

			if restrict_height:
				min_vector.y = 0.0

			# move away from closest point
			transforms.list[i].origin += min_vector.normalized() * offset

		offset *= consecutive_step_multiplier
"

[sub_resource type="Resource" id="Resource_tav4e"]
script = SubResource("GDScript_ntq0g")
iterations = 3
offset_step = 0.2
consecutive_step_multiplier = 0.75
enabled = true
override_global_seed = false
custom_seed = 0
restrict_height = true
reference_frame = 0

[sub_resource type="GDScript" id="GDScript_3qrhr"]
script/source = "@tool
extends \"base_modifier.gd\"


signal projection_completed


const ProtonScatterPhysicsHelper := preload(\"res://addons/proton_scatter/src/common/physics_helper.gd\")


@export var ray_direction := Vector3.DOWN
@export var ray_length := 10.0
@export var ray_offset := 1.0
@export var remove_points_on_miss := true
@export var align_with_collision_normal := false
@export_range(0.0, 90.0) var max_slope = 90.0
@export_flags_3d_physics var collision_mask = 1

var _last_hit: Dictionary


func _init() -> void:
	display_name = \"Project On Colliders\"
	category = \"Edit\"
	can_restrict_height = false
	global_reference_frame_available = true
	local_reference_frame_available = true
	individual_instances_reference_frame_available = true
	use_global_space_by_default()

	documentation.add_paragraph(
		\"Moves each transforms along the ray direction until they hit a collider.
		This is useful to avoid floating objects on uneven terrain for example.\")

	documentation.add_warning(
		\"This modifier only works when physics bodies are around. It will ignore
		simple MeshInstances nodes.\")

	var p := documentation.add_parameter(\"Ray direction\")
	p.set_type(\"Vector3\")
	p.set_description(
		\"In which direction we look for a collider. This default to the DOWN
		direction by default (look at the ground).\")
	p.add_warning(
		\"This is relative to the transform is local space is enabled, or aligned
		with the global axis if local space is disabled.\")

	p = documentation.add_parameter(\"Ray length\")
	p.set_type(\"float\")
	p.set_description(\"How far we look for other physics objects.\")
	p.set_cost(2)

	p = documentation.add_parameter(\"Ray offset\")
	p.set_type(\"Vector3\")
	p.set_description(
		\"Moves back the raycast origin point along the ray direction. This is
		useful if the initial transform is slightly below the ground, which would
		make the raycast miss the collider (since it would start inside).\")

	p = documentation.add_parameter(\"Remove points on miss\")
	p.set_type(\"bool\")
	p.set_description(
		\"When enabled, if the raycast didn't collide with anything, or collided
		with a surface above the max slope setting, the transform is removed
		from the list.
		This is useful to avoid floating objects that are too far from the rest
		of the scene's geometry.\")

	p = documentation.add_parameter(\"Align with collision normal\")
	p.set_type(\"bool\")
	p.set_description(
		\"Rotate the transform to align it with the collision normal in case
		the ray cast hit a collider.\")

	p = documentation.add_parameter(\"Max slope\")
	p.set_type(\"float\")
	p.set_description(
		\"Angle (in degrees) after which the hit is considered invalid.
		When a ray cast hit, the normal of the ray is compared against the
		normal of the hit. If you set the slope to 0°, the ray and the hit
		normal would have to be perfectly aligned to be valid. On the other
		hand, setting the maximum slope to 90° treats every collisions as
		valid regardless of their normals.\")

	p = documentation.add_parameter(\"Mask\")
	p.set_description(
		\"Only collide with colliders on these layers. Disabled layers will
		be ignored. It's useful to ignore players or npcs that might be on the
		scene when you're editing it.\")


func _process_transforms(transforms, domain, _seed) -> void:
	if transforms.is_empty():
		return

	# Create all the physics ray queries
	var domain_basis: Basis = domain.get_root().get_global_transform().basis
	var queries: Array[PhysicsRayQueryParameters3D] = []
	for t in transforms.list:
		var start = t.origin
		var end = t.origin
		var dir = ray_direction.normalized()

		if is_using_individual_instances_space():
			dir = t.basis * dir

		elif is_using_local_space():
			dir = domain_basis * dir

		start -= ray_offset * dir
		end += ray_length * dir

		var ray_query := PhysicsRayQueryParameters3D.new()
		ray_query.from = start
		ray_query.to = end
		ray_query.collision_mask = collision_mask

		queries.push_back(ray_query)

	# Run the queries in the physics helper since we can't access the PhysicsServer
	# from outside the _physics_process while also being in a separate thread.
	var physics_helper: ProtonScatterPhysicsHelper = domain.get_root().get_physics_helper()
	var ray_hits = await physics_helper.execute(queries)

	if ray_hits.is_empty():
		return

	# Apply the results

	var index := 0
	var d: float
	var t: Transform3D
	var remapped_max_slope = remap(max_slope, 0.0, 90.0, 0.0, 1.0)
	var is_point_valid := false

	for hit in ray_hits:
		is_point_valid = true

		if hit.is_empty():
			is_point_valid = false
		else:
			d = abs(Vector3.UP.dot(hit.normal))
			is_point_valid = d >= (1.0 - remapped_max_slope)

		if is_point_valid:
			t = transforms.list[index]

			if align_with_collision_normal:
				t = _align_with(t, hit.normal)

			t.origin = hit.position
			transforms.list[index] = t
			index += 1

		elif remove_points_on_miss:
			transforms.list.remove_at(index)

	if transforms.is_empty():
		warning += \"\"\"Every points have been removed. Possible reasons include: \\n
		+ No collider is close enough to the shapes.
		+ Ray length is too short.
		+ Ray direction is incorrect.
		+ Collision mask is not set properly.
		+ Max slope is too low.
		\"\"\"


func _align_with(t: Transform3D, normal: Vector3) -> Transform3D:
	var n1 = t.basis.y.normalized()
	var n2 = normal.normalized()

	var cosa = n1.dot(n2)
	var alpha = acos(cosa)
	var axis = n1.cross(n2)

	if axis == Vector3.ZERO:
		return t

	return t.rotated(axis.normalized(), alpha)
"

[sub_resource type="Resource" id="Resource_yd5c7"]
script = SubResource("GDScript_3qrhr")
ray_direction = Vector3(0, -1, 0)
ray_length = 5.0
ray_offset = 5.0
remove_points_on_miss = false
align_with_collision_normal = false
max_slope = 90.0
collision_mask = 1
enabled = true
override_global_seed = false
custom_seed = 0
restrict_height = false
reference_frame = 0

[sub_resource type="Resource" id="Resource_pyw2j"]
script = SubResource("GDScript_jiclh")
stack = Array[Resource]([SubResource("Resource_nvjs0"), SubResource("Resource_v6ok5"), SubResource("Resource_tav4e"), SubResource("Resource_yd5c7")])

[sub_resource type="GDScript" id="GDScript_ld5kj"]
script/source = "@tool
extends Node3D


const ScatterUtil := preload('./common/scatter_util.gd')


@export_category(\"ScatterItem\")
@export var proportion := 100:
	set(val):
		proportion = val
		ScatterUtil.request_parent_to_rebuild(self)

@export_enum(\"From current scene\", \"From disk\") var source = 1:
	set(val):
		source = val
		property_list_changed.emit()

@export_group(\"Source options\", \"source_\")
@export var source_scale_multiplier := 1.0:
	set(val):
		source_scale_multiplier = val
		ScatterUtil.request_parent_to_rebuild(self)

@export var source_ignore_position := true:
	set(val):
		source_ignore_position = val
		ScatterUtil.request_parent_to_rebuild(self)

@export var source_ignore_rotation := true:
	set(val):
		source_ignore_rotation = val
		ScatterUtil.request_parent_to_rebuild(self)

@export var source_ignore_scale := true:
	set(val):
		source_ignore_scale = val
		ScatterUtil.request_parent_to_rebuild(self)

@export_group(\"Override options\", \"override_\")
@export var override_material: BaseMaterial3D:
	set(val):
		override_material = val
		ScatterUtil.request_parent_to_rebuild(self)

@export var override_cast_shadow: GeometryInstance3D.ShadowCastingSetting = GeometryInstance3D.SHADOW_CASTING_SETTING_ON:
	set(val):
		override_cast_shadow = val
		ScatterUtil.request_parent_to_rebuild(self) # TODO - Only change the multimesh flag instead

var path: String:
	set(val):
		path = val
		_target_scene = load(path) if source != 0 else null
		ScatterUtil.request_parent_to_rebuild(self)

var source_position: Vector3
var source_rotation: Vector3
var source_scale: Vector3

var _target_scene: PackedScene


func _get_property_list() -> Array:
	var list := []

	if source == 0:
		list.push_back({
			name = \"path\",
			type = TYPE_NODE_PATH,
		})
	else:
		list.push_back({
			name = \"path\",
			type = TYPE_STRING,
			hint = PROPERTY_HINT_FILE,
		})

	return list


func get_item() -> Node3D:
	if path.is_empty():
		return null

	var node: Node3D

	if source == 0:
		node = get_node_or_null(path)
	else:
		node = _target_scene.instantiate()

	if node:
		_save_source_data(node)
		return node

	return null


# Takes a transform in input, scale it based on the local scale multiplier
# If the source transform is not ignored, also copy the source position, rotation and scale.
# Returns the processed transform
func process_transform(t: Transform3D) -> Transform3D:
	var origin = t.origin
	t.origin = Vector3.ZERO

	t = t.scaled(Vector3.ONE * source_scale_multiplier)

	if not source_ignore_scale:
		t = t.scaled(source_scale)

	if not source_ignore_rotation:
		t = t.rotated(t.basis.x.normalized(), source_rotation.x)
		t = t.rotated(t.basis.y.normalized(), source_rotation.y)
		t = t.rotated(t.basis.z.normalized(), source_rotation.z)

	t.origin = origin

	if not source_ignore_position:
		t.origin += source_position

	return t


func _save_source_data(node: Node3D) -> void:
	if not node:
		return

	source_position = node.position
	source_rotation = node.rotation
	source_scale = node.scale
"

[sub_resource type="GDScript" id="GDScript_vvd02"]
script/source = "@tool
extends Node3D


const ScatterUtil := preload('./common/scatter_util.gd')


@export_category(\"ScatterShape\")
@export var negative = false:
	set(val):
		negative = val
		update_gizmos()
		ScatterUtil.request_parent_to_rebuild(self)

@export var shape: ProtonScatterBaseShape:
	set(val):
		# Disconnect the previous shape if any
		if shape and shape.changed.is_connected(_on_shape_changed):
			shape.changed.disconnect(_on_shape_changed)

		shape = val
		if shape:
			shape.changed.connect(_on_shape_changed)

		update_gizmos()
		ScatterUtil.request_parent_to_rebuild(self)


func _ready() -> void:
	set_notify_transform(true)


func _notification(what):
	match what:
		NOTIFICATION_TRANSFORM_CHANGED:
			ScatterUtil.request_parent_to_rebuild(self)


func _set(property, _value):
	if not Engine.is_editor_hint():
		return false

	# Workaround to detect when the node was duplicated from the editor.
	if property == \"transform\":
		call_deferred(\"_on_node_duplicated\")

	return false


func _on_shape_changed() -> void:
	update_gizmos()
	ScatterUtil.request_parent_to_rebuild(self)


func _on_node_duplicated() -> void:
	shape = shape.get_copy() # Enfore uniqueness on duplicate, could be an option
"

[sub_resource type="GDScript" id="GDScript_14dh5"]
script/source = "@tool
class_name ProtonScatterBoxShape
extends ProtonScatterBaseShape


@export var size := Vector3.ONE:
	set(val):
		size = val
		_half_size = size * 0.5
		emit_changed()

var _half_size := Vector3.ONE


func get_copy():
	var copy = get_script().new()
	copy.size = size
	return copy


func is_point_inside(point: Vector3, global_transform: Transform3D) -> bool:
	var position = global_transform * -_half_size
	var local_point = global_transform.affine_inverse() * point
	return AABB(-_half_size, size).has_point(local_point)


func get_corners_global(gt: Transform3D) -> Array:
	var res := []
	var corners := [
		Vector3(-1, -1, -1),
		Vector3(-1, -1, 1),
		Vector3(1, -1, 1),
		Vector3(1, -1, -1),
		Vector3(-1, 1, -1),
		Vector3(-1, 1, 1),
		Vector3(1, 1, 1),
		Vector3(1, 1, -1),
	]

	for c in corners:
		c *= size * 0.5
		res.push_back(gt * c)

	return res


# Intersection between and box and a plane results in a polygon between 3 and 6
# vertices.
# Compute the intersection of each of the 12 edges to the plane, then recompute
# the polygon from the positions found.
func get_closed_edges(scatter_gt: Transform3D, shape_gt: Transform3D) -> Array[PackedVector2Array]:
	var polygon := PackedVector2Array()

	var a = scatter_gt.basis.x
	var b = scatter_gt.basis.z
	var c = a + b
	var o = scatter_gt.origin
	var plane = Plane(a + o, b + o, c + o)

	var box_edges := [
		# Bottom square
		[Vector3(-1, -1, -1), Vector3(-1, -1, 1)],
		[Vector3(-1, -1, 1), Vector3(1, -1, 1)],
		[Vector3(1, -1, 1), Vector3(1, -1, -1)],
		[Vector3(1, -1, -1), Vector3(-1, -1, -1)],

		# Top square
		[Vector3(-1, 1, -1), Vector3(-1, 1, 1)],
		[Vector3(-1, 1, 1), Vector3(1, 1, 1)],
		[Vector3(1, 1, 1), Vector3(1, 1, -1)],
		[Vector3(1, 1, -1), Vector3(-1, 1, -1)],

		# Vertical lines
		[Vector3(-1, -1, -1), Vector3(-1, 1, -1)],
		[Vector3(-1, -1, 1), Vector3(-1, 1, 1)],
		[Vector3(1, -1, 1), Vector3(1, 1, 1)],
		[Vector3(1, -1, -1), Vector3(1, 1, -1)],
	]

	var intersection_points := PackedVector3Array()
	var point
	var gt_inverse := scatter_gt.affine_inverse()
	var shape_gt_inverse := shape_gt.affine_inverse()

	for edge in box_edges:
		var p1 = (edge[0] * _half_size) * shape_gt_inverse
		var p2 = (edge[1] * _half_size) * shape_gt_inverse
		point = plane.intersects_segment(p1, p2)
		if point:
			intersection_points.push_back(gt_inverse * point)

	if intersection_points.size() < 3:
		return []

	var points_unordered := PackedVector2Array()
	for p in intersection_points:
		points_unordered.push_back(Vector2(p.x, p.z))

	polygon = Geometry2D.convex_hull(points_unordered)

	return [polygon]
"

[sub_resource type="Resource" id="Resource_7bswq"]
script = SubResource("GDScript_14dh5")
size = Vector3(13.8824, 1, 11.0734)

[sub_resource type="ProceduralSkyMaterial" id="ProceduralSkyMaterial_6jggr"]
sky_top_color = Color(0.337255, 0.580392, 0.866667, 1)
sky_horizon_color = Color(0.839216, 0.917647, 0.980392, 1)
sky_curve = 0.09
ground_bottom_color = Color(0.337255, 0.580392, 0.866667, 1)
ground_horizon_color = Color(0.839216, 0.917647, 0.980392, 1)

[sub_resource type="Sky" id="Sky_hc2nq"]
sky_material = SubResource("ProceduralSkyMaterial_6jggr")

[sub_resource type="Environment" id="Environment_pvafa"]
background_mode = 2
background_color = Color(0.647059, 0.839216, 0.945098, 1)
sky = SubResource("Sky_hc2nq")
ambient_light_source = 2
ambient_light_color = Color(0.427451, 0.501961, 0.552941, 1)
ambient_light_energy = 4.0
tonemap_mode = 3
tonemap_exposure = 0.7
tonemap_white = 1.45
ssao_enabled = true
ssil_enabled = true
glow_enabled = true
glow_strength = 0.75
volumetric_fog_enabled = true
volumetric_fog_density = 0.005
volumetric_fog_albedo = Color(0.337255, 0.580392, 0.866667, 1)
adjustment_enabled = true
adjustment_saturation = 1.1

[sub_resource type="Resource" id="Resource_dvoom"]
script = ExtResource("5_y2str")
amount = 1000
enabled = true
override_global_seed = false
custom_seed = 0
restrict_height = true
reference_frame = 1

[sub_resource type="Resource" id="Resource_bgqng"]
script = ExtResource("6_goa4k")
position = Vector3(0.15, 0.15, 0.15)
rotation = Vector3(20, 360, 20)
scale = Vector3(0.1, 0.1, 0.1)
enabled = false
override_global_seed = false
custom_seed = 0
restrict_height = false
reference_frame = 2

[sub_resource type="Resource" id="Resource_t2vab"]
script = ExtResource("7_ejpuv")
iterations = 3
offset_step = 0.2
consecutive_step_multiplier = 0.75
use_computeshader = true
enabled = true
override_global_seed = false
custom_seed = 0
restrict_height = true
reference_frame = 0

[sub_resource type="Resource" id="Resource_5nxjy"]
script = ExtResource("8_01k33")
ray_direction = Vector3(0, -1, 0)
ray_length = 5.0
ray_offset = 5.0
remove_points_on_miss = false
align_with_collision_normal = false
max_slope = 90.0
collision_mask = 1
exclude_mask = 0
enabled = true
override_global_seed = false
custom_seed = 0
restrict_height = false
reference_frame = 0

[sub_resource type="Resource" id="Resource_erosr"]
script = ExtResource("4_aa0xd")
stack = Array[Resource("res://addons/proton_scatter/src/modifiers/base_modifier.gd")]([SubResource("Resource_dvoom"), SubResource("Resource_bgqng"), SubResource("Resource_t2vab"), SubResource("Resource_5nxjy")])

[sub_resource type="Resource" id="Resource_iismt"]
script = ExtResource("11_3kkjq")
size = Vector3(33.1505, 1, 12.9923)

[sub_resource type="Resource" id="Resource_hiqmy"]
script = ExtResource("11_3kkjq")
size = Vector3(10.0799, 1, 5.74545)

[sub_resource type="Resource" id="Resource_dc0rp"]
script = ExtResource("11_3kkjq")
size = Vector3(4.18868, 1.44074, 2.23846)

[sub_resource type="Resource" id="Resource_wvyvj"]
script = ExtResource("11_3kkjq")
size = Vector3(1.84568, 1.44074, 1.41914)

[sub_resource type="StyleBoxEmpty" id="StyleBoxEmpty_1kk4u"]

[sub_resource type="StyleBoxEmpty" id="StyleBoxEmpty_bfhaf"]

[sub_resource type="StyleBoxEmpty" id="StyleBoxEmpty_wanmh"]

[sub_resource type="StyleBoxEmpty" id="StyleBoxEmpty_bpiee"]

[sub_resource type="StyleBoxEmpty" id="StyleBoxEmpty_38gns"]

[node name="MainMenu" type="CanvasLayer"]

[node name="3dBackground" type="Node3D" parent="."]

[node name="CSGCombiner3D" type="CSGCombiner3D" parent="3dBackground"]
use_collision = true

[node name="CSGBox3D" type="CSGBox3D" parent="3dBackground/CSGCombiner3D"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, -3.24043)
size = Vector3(66, 1, 12.9963)
material = ExtResource("1_uisu2")

[node name="CSGBox3D2" type="CSGBox3D" parent="3dBackground/CSGCombiner3D"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 7, -10)
size = Vector3(56, 14, 1)
material = ExtResource("2_a0r6c")

[node name="ProtonScatter" type="Node3D" parent="3dBackground"]
script = SubResource("GDScript_s3x0h")
global_seed = 0
show_output_in_tree = false
use_instancing = true
force_rebuild_on_load = true
enable_updates_in_game = false
scatter_parent = NodePath("")
dbg_disable_thread = false
modifier_stack = SubResource("Resource_pyw2j")

[node name="ScatterItem" type="Node3D" parent="3dBackground/ProtonScatter"]
script = SubResource("GDScript_ld5kj")
proportion = 100
source = 1
source_scale_multiplier = 1.0
source_ignore_position = true
source_ignore_rotation = true
source_ignore_scale = true
override_material = null
override_cast_shadow = 1
path = "res://Assets/Grass/stylized_grass.tscn"

[node name="ScatterShape" type="Node3D" parent="3dBackground/ProtonScatter"]
transform = Transform3D(1, 0, -2.98023e-08, 0, 1, 0, 2.98023e-08, 0, 1, 0, 0.588543, -2.57691)
script = SubResource("GDScript_vvd02")
negative = false
shape = SubResource("Resource_7bswq")

[node name="WorldEnvironment" type="WorldEnvironment" parent="3dBackground"]
environment = SubResource("Environment_pvafa")

[node name="DirectionalLight3D" type="DirectionalLight3D" parent="3dBackground/WorldEnvironment"]
transform = Transform3D(-0.977464, -0.152428, -0.146047, -0.139226, -0.0545621, 0.988756, -0.158683, 0.986807, 0.0321106, 9.864, 11.946, -3.33786e-06)
shadow_enabled = true

[node name="SubViewportContainer" type="SubViewportContainer" parent="3dBackground"]
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="SubViewport" type="SubViewport" parent="3dBackground/SubViewportContainer"]
handle_input_locally = false
size = Vector2i(1920, 1080)
render_target_update_mode = 4

[node name="Camera3D" type="Camera3D" parent="3dBackground/SubViewportContainer/SubViewport"]
transform = Transform3D(1, 0, 0, 0, 0.939693, 0.34202, 0, -0.34202, 0.939693, 0, 3.925, 2.92)

[node name="FogVolume" type="FogVolume" parent="3dBackground"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0.863344, -3.37528)
size = Vector3(27.4748, 1.00691, 13.7496)

[node name="ProtonScatter2" type="Node3D" parent="3dBackground"]
script = ExtResource("3_x3dau")
modifier_stack = SubResource("Resource_erosr")
Performance/use_chunks = true
Performance/chunk_dimensions = Vector3(15, 15, 15)

[node name="ScatterItem" type="Node3D" parent="3dBackground/ProtonScatter2"]
script = ExtResource("9_uqfs6")
source_scale_multiplier = 0.395
path = "res://Assets/Grass/stylized_grass.tscn"

[node name="ScatterShape" type="Node3D" parent="3dBackground/ProtonScatter2"]
transform = Transform3D(1, 0, -2.98023e-08, 0, 1, 0, 2.98023e-08, 0, 1, 0.628752, 0, -3.22949)
script = ExtResource("10_sagxs")
shape = SubResource("Resource_iismt")

[node name="ScatterShape2" type="Node3D" parent="3dBackground/ProtonScatter2"]
transform = Transform3D(1, 0, -2.98023e-08, 0, 1, 0, 2.98023e-08, 0, 1, 0.825597, 0, -5.21074)
script = ExtResource("10_sagxs")
negative = true
shape = SubResource("Resource_hiqmy")

[node name="ScatterShape3" type="Node3D" parent="3dBackground/ProtonScatter2"]
transform = Transform3D(0.866313, 0, -0.499501, 0, 1, 0, 0.499501, 0, 0.866313, 2.45008, -0.233862, -0.991147)
script = ExtResource("10_sagxs")
negative = true
shape = SubResource("Resource_dc0rp")

[node name="ScatterShape4" type="Node3D" parent="3dBackground/ProtonScatter2"]
transform = Transform3D(0.866313, 0, -0.499501, 0, 1, 0, 0.499501, 0, 0.866313, 4.05297, -0.233862, -1.72956)
script = ExtResource("10_sagxs")
negative = true
shape = SubResource("Resource_wvyvj")

[node name="Control" type="Control" parent="."]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="MarginContainer" type="MarginContainer" parent="Control"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 80
theme_override_constants/margin_top = 50
theme_override_constants/margin_right = 50
theme_override_constants/margin_bottom = 80

[node name="VBoxContainer" type="VBoxContainer" parent="Control/MarginContainer"]
layout_mode = 2

[node name="GameTitle" type="Label" parent="Control/MarginContainer/VBoxContainer"]
layout_mode = 2
theme_override_fonts/font = ExtResource("3_w3bp8")
theme_override_font_sizes/font_size = 80
text = "ProjectAD"

[node name="MarginContainer" type="MarginContainer" parent="Control/MarginContainer/VBoxContainer"]
custom_minimum_size = Vector2(0, 360)
layout_mode = 2

[node name="StartWorld1Btn" type="Button" parent="Control/MarginContainer/VBoxContainer"]
layout_mode = 2
size_flags_horizontal = 0
theme_override_colors/font_pressed_color = Color(1, 1, 1, 1)
theme_override_colors/font_hover_color = Color(1, 1, 0, 1)
theme_override_fonts/font = ExtResource("3_w3bp8")
theme_override_font_sizes/font_size = 50
theme_override_styles/normal = SubResource("StyleBoxEmpty_1kk4u")
theme_override_styles/hover = SubResource("StyleBoxEmpty_bfhaf")
theme_override_styles/pressed = SubResource("StyleBoxEmpty_wanmh")
theme_override_styles/disabled = SubResource("StyleBoxEmpty_bpiee")
theme_override_styles/focus = SubResource("StyleBoxEmpty_38gns")
text = "Start World 1"

[node name="StartWorld2Btn" type="Button" parent="Control/MarginContainer/VBoxContainer"]
layout_mode = 2
size_flags_horizontal = 0
theme_override_colors/font_pressed_color = Color(1, 1, 1, 1)
theme_override_colors/font_hover_color = Color(1, 1, 0, 1)
theme_override_fonts/font = ExtResource("3_w3bp8")
theme_override_font_sizes/font_size = 50
theme_override_styles/normal = SubResource("StyleBoxEmpty_1kk4u")
theme_override_styles/hover = SubResource("StyleBoxEmpty_bfhaf")
theme_override_styles/pressed = SubResource("StyleBoxEmpty_wanmh")
theme_override_styles/disabled = SubResource("StyleBoxEmpty_bpiee")
theme_override_styles/focus = SubResource("StyleBoxEmpty_38gns")
text = "Start World 2"

[node name="OptionsBtn" type="Button" parent="Control/MarginContainer/VBoxContainer"]
layout_mode = 2
size_flags_horizontal = 0
theme_override_colors/font_pressed_color = Color(1, 1, 1, 1)
theme_override_colors/font_hover_color = Color(1, 1, 0, 1)
theme_override_fonts/font = ExtResource("3_w3bp8")
theme_override_font_sizes/font_size = 50
theme_override_styles/normal = SubResource("StyleBoxEmpty_1kk4u")
theme_override_styles/hover = SubResource("StyleBoxEmpty_bfhaf")
theme_override_styles/pressed = SubResource("StyleBoxEmpty_wanmh")
theme_override_styles/disabled = SubResource("StyleBoxEmpty_bpiee")
theme_override_styles/focus = SubResource("StyleBoxEmpty_38gns")
text = "Options"

[node name="QuitBtn" type="Button" parent="Control/MarginContainer/VBoxContainer"]
layout_mode = 2
size_flags_horizontal = 0
theme_override_colors/font_pressed_color = Color(1, 1, 1, 1)
theme_override_colors/font_hover_color = Color(1, 1, 0, 1)
theme_override_fonts/font = ExtResource("3_w3bp8")
theme_override_font_sizes/font_size = 50
theme_override_styles/normal = SubResource("StyleBoxEmpty_1kk4u")
theme_override_styles/hover = SubResource("StyleBoxEmpty_bfhaf")
theme_override_styles/pressed = SubResource("StyleBoxEmpty_wanmh")
theme_override_styles/disabled = SubResource("StyleBoxEmpty_bpiee")
theme_override_styles/focus = SubResource("StyleBoxEmpty_38gns")
text = "Quit"

[node name="Bridge" parent="." instance=ExtResource("4_hjyux")]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0.760297, 0.552137, -5.33255)

[node name="Log" parent="." instance=ExtResource("5_wfq7t")]
transform = Transform3D(0.513466, 0, 0.85811, 0, 1, 0, -0.85811, 0, 0.513466, 2.24668, 0.769969, -1.03385)

[node name="Log2" parent="." instance=ExtResource("5_wfq7t")]
transform = Transform3D(7.06619e-10, -1, -1.10388e-11, 0.0156201, 0, 0.999878, -0.999878, -2.41044e-10, 0.0156201, 4.02586, -0.216242, -1.75475)
